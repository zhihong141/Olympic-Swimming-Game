<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>PS1 Top-View Olympic Swimming (Polished+)</title>
<style>
  :root{
    --bg:#0b0f1a;
    --ui:#eaeaea;
    --uiDim:#b8b8b8;
  }
  html,body{height:100%;margin:0;background:var(--bg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial,sans-serif;color:var(--ui);}
  .wrap{height:100%;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:12px;padding:12px;box-sizing:border-box;}
  canvas#screen{
    width:min(96vw, 960px);
    height:auto;
    aspect-ratio: 4 / 3;
    border:2px solid rgba(255,255,255,.18);
    border-radius:10px;
    box-shadow:0 12px 50px rgba(0,0,0,.55);
    background:#000;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    touch-action: manipulation;
  }
  .hint{
    max-width:min(96vw, 960px);
    color:var(--uiDim);
    font-size:13px;
    line-height:1.35;
    text-align:center;
  }
  .kbd{
    display:inline-block;
    padding:2px 6px;
    border:1px solid rgba(255,255,255,.25);
    border-bottom-color:rgba(255,255,255,.12);
    border-radius:6px;
    font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    color:var(--ui);
    background:rgba(255,255,255,.06);
  }
</style>
</head>
<body>

<!-- PS1-style Memory Card Intro -->
<div id="memCineWrap" style="position:fixed;inset:0;z-index:9999;display:flex;align-items:center;justify-content:center;background:#071018;">
  <canvas id="memCineCanvas" width="320" height="240" style="
    width:min(96vw, 960px);
    height:auto;
    aspect-ratio: 4 / 3;
    border:2px solid rgba(255,255,255,.18);
    border-radius:10px;
    box-shadow:0 12px 50px rgba(0,0,0,.55);
    background:#000;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
  "></canvas>
</div>

<script>
(() => {
  const wrap = document.getElementById('memCineWrap');
  const c = document.getElementById('memCineCanvas');
  const ctx = c.getContext('2d', { alpha:false, desynchronized:true });
  ctx.imageSmoothingEnabled = false;

  const W = 320, H = 240;
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));

  function clear(col){ ctx.fillStyle=col; ctx.fillRect(0,0,W,H); }
  function ps1Text(x,y,text,color='#eaeaea',scale=1,align='left'){
    ctx.save();
    ctx.textAlign=align; ctx.textBaseline='top';
    ctx.font=`${Math.floor(10*scale)}px ui-monospace, Menlo, Consolas, monospace`;
    ctx.globalAlpha=0.9; ctx.fillStyle='rgba(0,0,0,.65)'; ctx.fillText(text,x+1,y+1);
    ctx.globalAlpha=1; ctx.fillStyle=color; ctx.fillText(text,x,y);
    ctx.restore();
  }
  function panel(x,y,w,h,a=0.65){
    ctx.fillStyle=`rgba(0,0,0,${a})`; ctx.fillRect(x,y,w,h);
    ctx.strokeStyle='rgba(255,255,255,.14)'; ctx.strokeRect(x+0.5,y+0.5,w-1,h-1);
  }

  const slots = ['SLOT A','SLOT B','NO CARD'];
  let done=false;
  let t0=performance.now();

  function render(t){
    clear('#000');
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0,'#05070d'); g.addColorStop(1,'#000');
    ctx.fillStyle=g; ctx.fillRect(0,0,W,H);

    ps1Text(W/2, 18, 'MEMORY CARD', '#cfefff', 1.25, 'center');
    panel(26, 42, W-52, 166, 0.68);

    let sel = 1, status = 'SCANNING SLOTS...', prog = 0;
    if(t < 0.60){ status = 'BOOTING...'; sel = 1; }
    else if(t < 2.60){
      status = 'SCANNING SLOTS...';
      const tt = t - 0.60;
      const scrollSpeed = 2.6;
      const flipSpeed   = 0.9;
      const s = Math.sin(tt*scrollSpeed);
      const a = Math.abs(s);
      sel = (a < 0.34) ? 0 : (a < 0.67) ? 1 : 2;
      if(Math.floor(tt*flipSpeed)%2===1) sel = 2-sel;
    } else if(t < 3.10){ status = 'SELECTED: SLOT B'; sel = 1; }
    else if(t < 4.80){
      status = 'LOADING SLOT B...'; sel = 1;
      prog = clamp((t-3.10)/1.70, 0, 1);
    } else { status = 'OK'; sel = 1; prog = 1; }

    ps1Text(W/2, 54, status, 'rgba(255,255,255,.70)', 0.95, 'center');
    for(let i=0;i<3;i++){
      const y = 78 + i*26;
      ctx.fillStyle = (i===sel) ? 'rgba(124,255,255,.18)' : 'rgba(255,255,255,.06)';
      ctx.fillRect(42, y-6, W-84, 18);
      ps1Text(54, y-3, slots[i], (i===sel)?'#7cf':'rgba(255,255,255,.75)', 1.0, 'left');
      ps1Text(W-54, y-3, (i===sel)?'▶':'', '#7cf', 1.0, 'right');
    }
    const barX=48, barY=170, barW=W-96, barH=10;
    ctx.fillStyle='rgba(255,255,255,.08)'; ctx.fillRect(barX,barY,barW,barH);
    ctx.fillStyle='rgba(124,255,255,.35)'; ctx.fillRect(barX,barY,barW*prog,barH);
    ps1Text(W/2, 184, (prog>0 && prog<1) ? 'READING...' : (prog>=1 ? 'OK' : 'WAIT...'), 'rgba(255,255,255,.60)', 0.9, 'center');
    ps1Text(W/2, 206, 'DO NOT REMOVE CARD', 'rgba(255,255,255,.55)', 0.75, 'center');
    ps1Text(W/2, 222, 'PRESS ✕ TO SKIP', 'rgba(255,255,255,.45)', 0.75, 'center');
  }

  function finish(){
    if(done) return;
    done=true;
    wrap.style.display='none';
  }
  function tick(now){
    if(done) return;
    const t = (now - t0)/1000;
    render(t);
    if(t >= 4.80) finish();
    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);
  const skip = () => finish();
  window.addEventListener('keydown', skip, { once:true });
  window.addEventListener('pointerdown', skip, { once:true });
})();
</script>

<div class="wrap">
  <canvas id="screen" width="960" height="720" aria-label="Game canvas"></canvas>
  <div class="hint">
    Rendered internally at <b>320×240</b> and scaled up with nearest-neighbor.<br/>
    <b>In-race:</b> <span class="kbd">Space</span>/<span class="kbd">Enter</span> (or tap) to stroke • <span class="kbd">Shift</span> to sprint (costs stamina).<br/>
    <b>Menu:</b> <span class="kbd">↑</span>/<span class="kbd">↓</span> difficulty • <span class="kbd">←</span>/<span class="kbd">→</span> mode • <span class="kbd">Esc</span> back.<br/>
  </div>
</div>

<script>
(() => {
  // ====== PS1-ish low-res pipeline ======
  const W = 320, H = 240;
  const SCALE_CANVAS_W = 960, SCALE_CANVAS_H = 720;
  const out = document.getElementById('screen');
  out.width = SCALE_CANVAS_W; out.height = SCALE_CANVAS_H;
  const octx = out.getContext('2d', { alpha:false, desynchronized:true });
  octx.imageSmoothingEnabled = false;

  const fb = document.createElement('canvas');
  fb.width = W; fb.height = H;
  const ctx = fb.getContext('2d', { alpha:false, desynchronized:true });
  ctx.imageSmoothingEnabled = false;

  // ====== Utility ======
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp=(a,b,t)=>a+(b-a)*t;
  const rand=(a,b)=>a+Math.random()*(b-a);
  const now=()=>performance.now();

  // ====== Settings ======
  // Load settings from storage
  const SETTINGS_KEY = 'ps1_swim_settings_v1';
  let settings = { dither:true, crt:true, reducedMotion:false, vibration:true, sfxVolume:'MED' }; // LOW, MED, HIGH
  try{
    const saved = localStorage.getItem(SETTINGS_KEY);
    if(saved) settings = { ...settings, ...JSON.parse(saved) };
  }catch(e){}

  function saveSettings(){
    try{ localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings)); }catch(e){}
  }

  // ====== Input ======
  let pressed=false, sprintHeld=false, anyKey=false;
  let lastPtr={x:0,y:0,down:false};

  window.addEventListener('keydown', (e)=>{
    anyKey=true;
    if(e.code==='Space' || e.code==='Enter'){ pressed=true; e.preventDefault(); }
    if(e.key==='Shift'){ sprintHeld=true; }
  }, {passive:false});
  window.addEventListener('keyup', (e)=>{
    if(e.code==='Space' || e.code==='Enter'){ pressed=false; }
    if(e.key==='Shift'){ sprintHeld=false; }
  });
  out.addEventListener('pointerdown', (ev)=>{
    pressed=true;
    const r=out.getBoundingClientRect();
    const sx=(ev.clientX-r.left)/r.width;
    const sy=(ev.clientY-r.top)/r.height;
    lastPtr.x = sx*W;
    lastPtr.y = sy*H;
    lastPtr.down = true;
  }, {passive:true});
  out.addEventListener('pointerup', ()=>{ pressed=false; lastPtr.down=false; }, {passive:true});
  out.addEventListener('pointercancel', ()=>{ pressed=false; }, {passive:true});

  // ====== SFX ======
  let audioCtx=null;
  function ensureAudio(){ if(audioCtx) return; try{ audioCtx=new (window.AudioContext||window.webkitAudioContext)(); }catch(e){} }

  const volMap = { 'LOW':0.4, 'MED':0.7, 'HIGH':1.0 };

  function beep(freq=800, dur=0.05, vol=0.08, type='square'){
    if(!audioCtx) return;
    const t=audioCtx.currentTime;
    const o=audioCtx.createOscillator();
    const g=audioCtx.createGain();
    o.type=type;
    o.frequency.setValueAtTime(freq,t);

    // Apply master volume
    const master = volMap[settings.sfxVolume] || 0.7;
    const effectiveVol = vol * master;

    g.gain.setValueAtTime(0.0001,t);
    g.gain.exponentialRampToValueAtTime(effectiveVol,t+0.006);
    g.gain.exponentialRampToValueAtTime(0.0001,t+dur);
    o.connect(g); g.connect(audioCtx.destination);
    o.start(t); o.stop(t+dur+0.02);
  }
  const sfx={
    tapGood(){beep(1100,0.04,0.07,'square');},
    tapOk(){beep(840,0.035,0.055,'square');},
    tapBad(){beep(520,0.055,0.06,'square');},
    exhausted(){beep(240,0.11,0.09,'sawtooth');},
    turn(){beep(900,0.045,0.06,'square');},
    finish(){beep(660,0.06,0.08,'square'); setTimeout(()=>beep(990,0.06,0.07,'square'),65);},
    ui(){beep(760,0.035,0.05,'square');},
    win(){beep(880,0.08,0.09,'square'); setTimeout(()=>beep(1180,0.09,0.08,'square'),90);},
    lose(){beep(260,0.10,0.10,'sawtooth'); setTimeout(()=>beep(180,0.12,0.10,'sawtooth'),120);},
    countLow(){ beep(420, 0.12, 0.12, 'square'); },
    countHigh(){ beep(1020, 0.35, 0.15, 'square'); }
  };
  function userGestureAudio(){ ensureAudio(); if(audioCtx && audioCtx.state==='suspended') audioCtx.resume().catch(()=>{}); }
  window.addEventListener('pointerdown', userGestureAudio, {passive:true});
  window.addEventListener('keydown', userGestureAudio, {passive:true});

  // ====== States & Fades ======
  const STATE={BOOT:0, MENU:1, RACE:2, RESULT:3, GAUNTLET_HUB:4, GAUNTLET_WIN:5, GAUNTLET_LOSE:6, MEMORY:7, SAVING:8, OPTIONS:9, PAUSE:10};
  let state=STATE.BOOT;

  const trans = { active:false, t:0, dur:0.55, targetState:null, onMid:null };
  function transitionTo(newState, onMidpoint){
    if(trans.active) return;
    trans.active = true;
    trans.t = 0;
    trans.targetState = newState;
    trans.onMid = onMidpoint || null;
  }

  // ====== Pool geometry ======
  const pool={ topY:34, botY:212, topW:230, botW:294, cx:W/2, lanes:8 };
  function laneXAt(y,laneIdx){
    const t=(y-pool.topY)/(pool.botY-pool.topY);
    const halfW=lerp(pool.topW,pool.botW,t)/2;
    const left=pool.cx-halfW;
    const laneW=(halfW*2)/pool.lanes;
    return left+laneW*(laneIdx+0.5);
  }
  function laneWAt(y){
    const t=(y-pool.topY)/(pool.botY-pool.topY);
    return lerp(pool.topW,pool.botW,t)/pool.lanes;
  }

  const PAL={
    water1:'#0b4b68', water2:'#0a3b55', foam:'#cfefff',
    ropeR:'#ff5b5b', ropeB:'#58a6ff',
    tile1:'#c9d2d2', tile2:'#9fb0b0',
    ui:'#eaeaea', uiDim:'#b8b8b8',
    gold:'#ffd24a', danger:'#ff6a6a'
  };

  // ====== Visual FX ======
  const bayer4=[0,8,2,10,12,4,14,6,3,11,1,9,15,7,13,5];
  function ditherOverlay(intensity=0.10){
    const img=ctx.getImageData(0,0,W,H);
    const d=img.data;
    for(let y=0;y<H;y++) for(let x=0;x<W;x++){
      const i=(y*W+x)*4;
      const t=bayer4[((y&3)<<2)|(x&3)]/15;
      const add=(t-0.5)*intensity*255;
      d[i]=clamp(d[i]+add,0,255);
      d[i+1]=clamp(d[i+1]+add,0,255);
      d[i+2]=clamp(d[i+2]+add,0,255);
    }
    ctx.putImageData(img,0,0);
  }
  function crtOverlay(timeS){
    const pr = getPressure ? getPressure() : 0;
    ctx.globalAlpha=0.14 + pr*0.06;
    ctx.fillStyle='#000';
    for(let y=0;y<H;y+=2) ctx.fillRect(0,y,W,1);
    ctx.globalAlpha=1;
    const g=ctx.createRadialGradient(W/2,H/2,40,W/2,H/2,190);
    g.addColorStop(0,'rgba(0,0,0,0)'); g.addColorStop(1,`rgba(0,0,0,${0.35 + pr*0.18})`);
    ctx.fillStyle=g; ctx.fillRect(0,0,W,H);
    ctx.globalAlpha=0.10;
    ctx.fillStyle=`rgba(255,255,255,${0.08+0.04*Math.sin(timeS*2.2)})`;
    ctx.fillRect(0,0,W,1);
    ctx.globalAlpha=1;
  }

  const sparks=[];
  function spawnSparks(x,y,count=8){
    for(let i=0;i<count;i++) sparks.push({x,y,vx:rand(-20,20)/60,vy:rand(-26,-8)/60,life:rand(0.15,0.28),t:0});
  }
  function stepSparks(dt){
    for(let i=sparks.length-1;i>=0;i--){
      const p=sparks[i];
      p.t+=dt; p.x+=p.vx*60*dt; p.y+=p.vy*60*dt; p.vy+=28*dt;
      if(p.t>=p.life) sparks.splice(i,1);
    }
  }
  function drawSparks(){
    for(const p of sparks){
      const a=1-p.t/p.life;
      ctx.globalAlpha=a; ctx.fillStyle='#fff';
      ctx.fillRect(p.x|0,p.y|0,1,1);
      if(a>0.65) ctx.fillRect((p.x+1)|0,(p.y)|0,1,1);
      ctx.globalAlpha=1;
    }
  }

  // ====== Race Logic ======
  const LENGTH_M=50;
  const RACE_TYPES = [
    { id:'SPRINT100', label:'100m SPRINT', lengths:2, desc:'Short burst. Timing is everything.' },
    { id:'CLASSIC300', label:'300m CLASSIC', lengths:6, desc:'Balanced. Master pacing + timing.' },
    { id:'ENDURANCE800', label:'800m ENDURANCE', lengths:16, desc:'Long grind. Stamina management wins.' }
  ];
  let raceTypeSel = 1;
  let raceType = RACE_TYPES[raceTypeSel];
  let totalLengths = raceType.lengths;
  let totalM = LENGTH_M * totalLengths;

  const GAUNTLET_START_NPCS=7; // 7 wins to clear

  const AI_TYPES=['SPRINTER','PACER','CHOKER','CLUTCH'];
  function makeSwimmer(lane,isPlayer=false){
    const type=isPlayer?null:AI_TYPES[(Math.random()*AI_TYPES.length)|0];

    // Check for Gold Cap Unlock (if player beat Gauntlet Hard = 7 wins)
    let hasGold = false;
    if(isPlayer && mem.gauntletBestStage && mem.gauntletBestStage.hard >= 7){
        hasGold = true;
    }

    return {
      lane,isPlayer,dist:0,v:0,strokeTimer:0,stam:1,
      cap:isPlayer? (hasGold?PAL.gold:'#7cf') : ['#ff6a6a','#69ff7b','#ffd24a','#b38bff','#58a6ff','#ffb86b','#b8fffa'][lane%7],
      body:'#f0d9c7', bob:rand(0,Math.PI*2),
      // Nerfed AI skill to be more human-like (was 0.80 - 0.995)
      aiSkill:isPlayer?0:rand(0.60,0.90),
      aiType:type, aiCadence:rand(1.05,1.30),
      finishMs:null, flash:0, turnFlash:0, lastStrokeQ:0, exhaustedBuzz:0
    };
  }

  let swimmers=[];
  const tech = { taps:0, green:0, near:0, bad:0, stamSpent:0, sprintTaps:0, lastStam:1, leadCalls:0 };
  function resetTech(){
    tech.taps=tech.green=tech.near=tech.bad=0;
    tech.stamSpent=0; tech.sprintTaps=0; tech.lastStam=1; tech.leadCalls=0;
  }

  const comm = { q:[], cur:null, t:0, lock:0 };
  function say(text, color='rgba(255,255,255,.85)', dur=1.15, pri=0){
    if(comm.lock>0 && pri<=0) return;
    comm.q.push({text,color,dur,pri});
    if(comm.q.length>6) comm.q.shift();
    comm.lock = 0.18;
  }
  function stepCommentary(dt){
    comm.lock=Math.max(0,comm.lock-dt);
    if(!comm.cur){
      if(comm.q.length){
        comm.q.sort((a,b)=>b.pri-a.pri);
        comm.cur = comm.q.shift();
        comm.t = comm.cur.dur;
      }
    }else{
      comm.t -= dt;
      if(comm.t<=0) comm.cur=null;
    }
  }

  function getPressure(){
    const p = swimmers.find(s=>s.isPlayer);
    if(!p) return 0;
    const staminaStress = clamp((0.35 - p.stam) / 0.35, 0, 1);
    const lastLapStress = (getPlayerLapIndex()===totalLengths-1) ? 0.55 : 0.0;
    const gauntletStress = (mode===MODE.GAUNTLET) ? clamp((g_stage/GAUNTLET_START_NPCS),0,1) : 0;
    return clamp(staminaStress*0.55 + lastLapStress*0.25 + gauntletStress*0.35, 0, 1);
  }
  function drawPressureOverlay(timeS){
    const pr = getPressure();
    if(pr<=0.001) return;
    ctx.save();
    ctx.globalAlpha = 0.10 + pr*0.20;
    const g = ctx.createRadialGradient(W/2,H/2,50,W/2,H/2,190);
    g.addColorStop(0,'rgba(0,0,0,0)');
    g.addColorStop(1,'rgba(0,0,0,0.65)');
    ctx.fillStyle=g; ctx.fillRect(0,0,W,H);
    if(!settings.reducedMotion && Math.random() < pr*0.25){
      const y = (rand(40,H-40))|0;
      ctx.globalAlpha = 0.10 + pr*0.22;
      ctx.fillStyle = 'rgba(255,255,255,.35)';
      ctx.fillRect(0,y,W,1);
      ctx.globalAlpha = 0.10 + pr*0.16;
      ctx.fillStyle = 'rgba(0,0,0,.55)';
      ctx.fillRect(0,y+2,W,2);
    }
    ctx.globalAlpha = 0.08 + pr*0.18;
    ctx.fillStyle = (Math.sin(timeS*9.0)>0) ? '#ff6a6a' : '#ffd24a';
    ctx.fillRect(0,0,1,1);
    ctx.restore();
  }
  function drawCommentary(){
    if(!comm.cur) return;
    const pad=6;
    ctx.save();
    ctx.font='10px ui-monospace, Menlo, Consolas, monospace';
    const w = Math.min(W-30, ctx.measureText(comm.cur.text).width + pad*2);
    const x = (W-w)/2;
    const y = 52;
    ctx.globalAlpha=0.75; ctx.fillStyle='rgba(0,0,0,.65)'; ctx.fillRect(x,y,w,16);
    ctx.globalAlpha=1;
    drawPS1Text(W/2,y+2,comm.cur.text,comm.cur.color,0.95,'center');
    ctx.restore();
  }

  // ====== Splits ======
  let lastSplitObj = null;
  function showSplit(dist, tSec){
    lastSplitObj = { text: `${dist}m  ${tSec.toFixed(2)}`, timer: 2.5 };
  }
  function drawSplitPopup(){
    if(!lastSplitObj || lastSplitObj.timer <= 0) return;
    const alpha = clamp(lastSplitObj.timer, 0, 1);
    // PS1 style center screen popup
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    const w = 120, h = 30;
    ctx.fillRect((W-w)/2, (H-h)/2 - 20, w, h);
    ctx.strokeStyle = '#7cf';
    ctx.strokeRect((W-w)/2, (H-h)/2 - 20, w, h);

    // blink logic
    const blink = (lastSplitObj.timer > 2.0 && Math.floor(now()/100)%2===0) ? '#fff' : '#ffd24a';

    drawPS1Text(W/2, (H-h)/2 - 20 + 10, 'SPLIT TIME', 'rgba(255,255,255,0.7)', 0.8, 'center');
    drawPS1Text(W/2, (H-h)/2 - 20 + 20, lastSplitObj.text, blink, 1.2, 'center');

    ctx.restore();
  }

  const playerLane=3;
  let raceTimeMs=0, countdown=0, lastCountdownCeil=4, resultLock=0;
  const rhythm={ phase:0, speed:1.0, sweet:0.16, target:0.75 };

  let diff={ name:'normal', dragMul:1.45, aiMul:1.65, sweet:0.16, stamDrainMul:1.40, stamRecMul:0.80 };
  function applyDifficulty(which){
    if(which==='easy'){
      diff={ name:'easy', dragMul:1.00, aiMul:1.05, sweet:0.25, stamDrainMul:1.00, stamRecMul:1.15 };
      rhythm.speed=0.95; rhythm.sweet=diff.sweet;
    }else if(which==='normal'){
      diff={ name:'normal', dragMul:1.45, aiMul:1.32, sweet:0.20, stamDrainMul:1.40, stamRecMul:0.80 };
      rhythm.speed=1.05; rhythm.sweet=diff.sweet;
    }else{
      diff={ name:'hard', dragMul:1.70, aiMul:1.55, sweet:0.15, stamDrainMul:1.65, stamRecMul:0.70 };
      rhythm.speed=1.15; rhythm.sweet=diff.sweet;
    }
  }
  applyDifficulty('normal');

  const MODE={ QUICK:0, GAUNTLET:1 };
  let sprintDisabled = false;
  const HEAT_MODIFIERS = [
    { id:'TIGHT_TIMING', label:'TIGHT TIMING', desc:'Green timing window reduced', apply(){ rhythm.sweet *= 0.85; } },
    { id:'ROUGH_WATER', label:'ROUGH WATER', desc:'Higher drag this heat', apply(){ diff.dragMul *= 1.15; } },
    { id:'NO_SPRINT', label:'NO SPRINT', desc:'Sprint disabled', apply(){ sprintDisabled = true; } },
    { id:'ENDURANCE', label:'ENDURANCE TEST', desc:'Higher stamina drain', apply(){ diff.stamDrainMul *= 1.15; } }
  ];
  let mode=MODE.QUICK;
  const menuItems=[
    {label:'EASY',diff:'easy'},
    {label:'NORMAL',diff:'normal'},
    {label:'HARD',diff:'hard'},
    {label:'OPTIONS', action:'options'}
  ];
  let menuSel=1;

  let g_remainingNpcs=GAUNTLET_START_NPCS;
  let g_playerCarryStam = 1.0;
  let g_npcCarryMul = 1.0;
  let g_heatModifier = null;
  let g_stage=0;

  const RECORD_KEY='ps1_swim_records_v2';
  const MEM_KEY='ps1_swim_memcard_v1';
  const storageOK = (()=>{ try{ const k='__ps1swim_test__'; localStorage.setItem(k,'1'); localStorage.removeItem(k); return true; }catch(e){ return false; } })();
  function loadMem(){ try{ if(storageOK) return JSON.parse(localStorage.getItem(MEM_KEY)||'{}')||{}; }catch(e){} return window.__ps1swim_mem || {}; }
  function saveMem(obj){ try{ if(storageOK){ localStorage.setItem(MEM_KEY,JSON.stringify(obj)); return; } }catch(e){} window.__ps1swim_mem = obj; }
  let mem = loadMem();
  if(!mem.quickBest) mem.quickBest = {};
  if(!mem.gauntletBestStage) mem.gauntletBestStage = { easy:0, normal:0, hard:0 };
  if(!mem.lastPlayed) mem.lastPlayed = '';
  if(!mem.totalHeats) mem.totalHeats = 0; // Initialize total heats
  function memTouch(){ const d = new Date(); mem.lastPlayed = d.toLocaleString(); saveMem(mem); }
  function loadRecords(){ try{return JSON.parse(localStorage.getItem(RECORD_KEY)||'{}')||{};}catch(e){return{};} }
  function saveRecords(obj){ try{localStorage.setItem(RECORD_KEY,JSON.stringify(obj));}catch(e){} }
  let records=loadRecords();
  let lastRace={ diff:'normal', full:[], playerPos:null, playerTime:null };

  function allFinished(){ for(const s of swimmers) if(s.finishMs===null) return false; return true; }
  function updateRecords(){
    const rank=swimmers.slice().sort((a,b)=>(a.finishMs??1e18)-(b.finishMs??1e18));
    const player=swimmers.find(s=>s.isPlayer);
    const playerPos=rank.findIndex(s=>s.isPlayer)+1;
    const playerSec=(player.finishMs||0)/1000;
    lastRace.diff=diff.name;
    lastRace.full=rank.map((s,i)=>({pos:i+1,lane:s.lane+1,time:(s.finishMs||0)/1000}));
    lastRace.playerPos=playerPos;
    lastRace.playerTime=playerSec;
    const best=records[diff.name];
    if(best==null || playerSec<best){ records[diff.name]=playerSec; saveRecords(records); }

    // Update Memory Card Stats
    mem.totalHeats = (mem.totalHeats || 0) + 1; // Increment total heats

    if(mode===MODE.QUICK){
      const key = `${diff.name}_${raceType.id}`;
      const prev = mem.quickBest[key];
      if(prev==null || playerSec < prev){ mem.quickBest[key]=playerSec; }
    }
    if(mode===MODE.GAUNTLET){
      const prevStage = mem.gauntletBestStage[diff.name] ?? 0;
      const stageNow = (GAUNTLET_START_NPCS - g_remainingNpcs);
      if(stageNow > prevStage) mem.gauntletBestStage[diff.name]=stageNow;
    }
    memTouch();
  }
  function ensureLastRace(){ if(lastRace.full.length) return; if(!allFinished()) return; updateRecords(); }

  function resetRace(fieldNpcs=7){
    sprintDisabled = false;
    swimmers=[];
    const lanes=[0,1,2,3,4,5,6,7].filter(l=>l!==playerLane);
    for(let i=lanes.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [lanes[i],lanes[j]]=[lanes[j],lanes[i]]; }
    const useNpcs=clamp(fieldNpcs,1,7);
    const used=[playerLane, ...lanes.slice(0,useNpcs)];
    used.sort((a,b)=>a-b);
    for(const ln of used){
      const sw = makeSwimmer(ln, ln===playerLane);
      if(mode===MODE.GAUNTLET){
        if(sw.isPlayer){ sw.stam = g_playerCarryStam; }
        else { sw.stam *= g_npcCarryMul; }
      }
      swimmers.push(sw);
    }
    if(mode===MODE.GAUNTLET && g_heatModifier){ g_heatModifier.apply(); }
    raceTimeMs=0;
    countdown=3.0;
    lastCountdownCeil=4;
    resetTech();
    memTouch();
    resultLock=0;
    sparks.length=0;
    camShake=0; lastLapPunch=0; lastLapPulse=0; finishPunch=0;
    lastRace.full=[];
    lastSplitObj=null;
  }

  function clear(c){ ctx.fillStyle=c; ctx.fillRect(0,0,W,H); }
  function drawPS1Text(x,y,text,color='#eaeaea',scale=1,align='left'){
    ctx.save();
    ctx.textAlign=align; ctx.textBaseline='top';
    ctx.font=`${Math.floor(10*scale)}px ui-monospace, Menlo, Consolas, monospace`;
    ctx.globalAlpha=0.9; ctx.fillStyle='rgba(0,0,0,.65)'; ctx.fillText(text,x+1,y+1);
    ctx.globalAlpha=1; ctx.fillStyle=color; ctx.fillText(text,x,y);
    ctx.restore();
  }

  const lengthIndex=(dist)=>Math.floor(dist/LENGTH_M);
  const posInLength=(dist,lenIdx)=>dist-lenIdx*LENGTH_M;
  const dirForLength=(lenIdx)=>(lenIdx%2===0)?1:-1;
  const meterToScreenY=(mInLen,dir)=> dir===1 ? lerp(pool.botY-6,pool.topY+6,mInLen/LENGTH_M) : lerp(pool.topY+6,pool.botY-6,mInLen/LENGTH_M);
  function getPlayerLapIndex(){
    const p=swimmers.find(s=>s.isPlayer); if(!p) return 0;
    return clamp(lengthIndex(p.dist),0,totalLengths-1);
  }

  function drawPool(timeS){
    ctx.fillStyle=PAL.tile2; ctx.fillRect(0,0,W,H);
    ctx.globalAlpha=0.22; ctx.fillStyle=PAL.tile1;
    for(let y=0;y<H;y+=8) for(let x=0;x<W;x+=8) if(((x>>3)+(y>>3))&1) ctx.fillRect(x,y,8,8);
    ctx.globalAlpha=1;

    // Crowd
    const lastLap=getPlayerLapIndex()===totalLengths-1;
    const pulse=lastLap?(0.5+0.5*Math.sin(timeS*8.0)):0;
    ctx.fillStyle='rgba(12,14,18,.95)'; ctx.fillRect(0,0,W,pool.topY-2);
    for(let i=0;i<220;i++){
      const x=(Math.random()*W)|0, y=(Math.random()*(pool.topY-6))|0;
      ctx.fillStyle=(Math.random()<0.6)?'rgba(180,190,210,.22)':'rgba(90,120,140,.18)';
      ctx.fillRect(x,y,1,1);
    }
    ctx.fillStyle='rgba(12,14,18,.95)'; ctx.fillRect(0,pool.botY+2,W,H-(pool.botY+2));
    for(let i=0;i<220;i++){
      const x=(Math.random()*W)|0, y=(pool.botY+3 + Math.random()*(H-(pool.botY+6)))|0;
      ctx.fillStyle=(Math.random()<0.6)?'rgba(180,190,210,.22)':'rgba(90,120,140,.18)';
      ctx.fillRect(x,y,1,1);
    }
    if(lastLap){
      // Final Lap Hype: Flash bulbs + Gold banners
      ctx.globalAlpha=0.25+0.35*pulse; ctx.fillStyle=PAL.gold;
      ctx.fillRect(0,pool.topY-2,W,2); ctx.fillRect(0,pool.botY+0,W,2);
      ctx.globalAlpha=1;
      // Flickering text
      const textColor = (Math.floor(timeS*10)%2===0) ? PAL.gold : '#fff';
      drawPS1Text(W/2,6,'FINAL LAP!', textColor, 1.1 + pulse*0.1, 'center');

      // Random Flash Bulbs
      if(Math.random()<0.08 && !settings.reducedMotion){
          ctx.fillStyle = 'rgba(255,255,255,0.4)';
          ctx.fillRect(0,0,W,H);
      }
    }

    ctx.save();
    ctx.beginPath();
    const topHalf=pool.topW/2, botHalf=pool.botW/2;
    ctx.moveTo(pool.cx-topHalf,pool.topY); ctx.lineTo(pool.cx+topHalf,pool.topY);
    ctx.lineTo(pool.cx+botHalf,pool.botY); ctx.lineTo(pool.cx-botHalf,pool.botY);
    ctx.closePath(); ctx.clip();

    ctx.fillStyle=PAL.water2; ctx.fillRect(0,0,W,H);
    ctx.globalAlpha=0.35; ctx.fillStyle=PAL.water1;
    const motionPhase=settings.reducedMotion?0:timeS;
    for(let y=pool.topY;y<=pool.botY;y+=4){
      const wob=settings.reducedMotion?0:Math.floor(Math.sin(motionPhase*2.0+y*0.08)*1.2);
      const band=(((y>>2)+Math.floor(motionPhase*6))&1);
      if(band){
        const t=(y-pool.topY)/(pool.botY-pool.topY);
        const halfW=lerp(pool.topW,pool.botW,t)/2;
        ctx.fillRect(pool.cx-halfW+wob,y,halfW*2,2);
      }
    }
    ctx.globalAlpha=1;

    for(let i=0;i<=pool.lanes;i++){
      ctx.strokeStyle='rgba(232,226,208,.45)'; ctx.lineWidth=1;
      ctx.beginPath();
      const xTop=lerp(pool.cx-pool.topW/2,pool.cx+pool.topW/2,i/pool.lanes);
      const xBot=lerp(pool.cx-pool.botW/2,pool.cx+pool.botW/2,i/pool.lanes);
      ctx.moveTo(xTop,pool.topY); ctx.lineTo(xBot,pool.botY); ctx.stroke();
    }
    for(let i=1;i<pool.lanes;i++){
      for(let y=pool.topY;y<pool.botY;y+=3){
        const t=(y-pool.topY)/(pool.botY-pool.topY);
        const halfW=lerp(pool.topW,pool.botW,t)/2;
        const left=pool.cx-halfW;
        const laneW=(halfW*2)/pool.lanes;
        const x=left+laneW*i;
        const c=(((y+i*7+Math.floor(timeS*24))>>1)&1)?PAL.ropeR:PAL.ropeB;
        ctx.fillStyle=c; ctx.globalAlpha=0.75; ctx.fillRect(x|0,y,1,1);
      }
      ctx.globalAlpha=1;
    }
    ctx.globalAlpha=0.85; ctx.fillStyle='#fff';
    ctx.fillRect(pool.cx-pool.topW/2,pool.topY,pool.topW,2);
    ctx.fillRect(pool.cx-pool.botW/2,pool.botY-2,pool.botW,2);
    ctx.globalAlpha=1;
    ctx.restore();

    for(let i=0;i<pool.lanes;i++){
      const y=pool.botY+4;
      const t=(y-pool.topY)/(pool.botY-pool.topY);
      const halfW=lerp(pool.topW,pool.botW,t)/2;
      const left=pool.cx-halfW;
      const laneW=(halfW*2)/pool.lanes;
      const x=left+laneW*(i+0.5);
      const bw=Math.max(6,Math.floor(laneW*0.35)), bh=6;
      ctx.fillStyle='rgba(20,24,30,.9)'; ctx.fillRect((x-bw/2)|0,y,bw,bh);
      drawPS1Text(x|0,y+1,String(i+1),'#eaeaea',0.9,'center');
    }
  }

  function drawSwimmer(sw,timeS){
    let lenIdx=clamp(lengthIndex(sw.dist),0,totalLengths-1);
    let mInLen=clamp(posInLength(sw.dist,lenIdx),0,LENGTH_M);
    if(sw.finishMs!==null){ lenIdx=totalLengths-1; mInLen=LENGTH_M; }
    const dir=dirForLength(lenIdx);
    const y=meterToScreenY(mInLen,dir);
    const x=laneXAt(y,sw.lane);
    const laneW=laneWAt(y);
    const s=clamp(laneW/30,0.55,1.15);

    const tired=clamp((0.25-sw.stam)/0.25,0,1);
    const bobAmp=lerp(0.8,0.45,tired);
    const bob=Math.sin(timeS*6+sw.bob)*bobAmp;

    ctx.globalAlpha=0.25; ctx.fillStyle='#000';
    ctx.beginPath(); ctx.ellipse(x,y+2,6*s,2.5*s,0,0,Math.PI*2); ctx.fill();
    ctx.globalAlpha=1;
    ctx.fillStyle='rgba(15,20,28,.55)'; ctx.fillRect((x-5*s)|0,(y-3*s+bob)|0,(10*s)|0,(6*s)|0);
    ctx.fillStyle=sw.body; ctx.fillRect((x-4*s)|0,(y-2*s+bob)|0,(8*s)|0,(4*s)|0);
    ctx.fillStyle=sw.body; ctx.beginPath(); ctx.arc(x,y-5*s+bob,2.5*s,0,Math.PI*2); ctx.fill();
    ctx.fillStyle=sw.cap; ctx.fillRect((x-3*s)|0,(y-8*s+bob)|0,(6*s)|0,(3*s)|0);

    const armSpeed=lerp(1.0,0.75,tired);
    const armPhase=((sw.strokeTimer*6)*armSpeed+sw.bob)%(Math.PI*2);
    const armUp=Math.sin(armPhase)*0.5+0.5;
    const reach=lerp(-6,8,armUp)*s*(dir===1?1:0.9);
    const spread=lerp(6,2,armUp)*s;
    ctx.fillStyle=sw.body;
    ctx.beginPath(); ctx.moveTo(x,y-1*s+bob); ctx.lineTo(x-spread,y+2*s+bob); ctx.lineTo(x+reach,y+1*s); ctx.closePath(); ctx.fill();
    ctx.fillStyle='rgba(255,255,255,.15)'; ctx.fillRect((x-2*s)|0,(y+2*s+bob)|0,(4*s)|0,((3+sw.v*0.25)*s)|0);

    const splashBase=clamp(sw.v*0.18,0,1)*(0.3+armUp*0.7);
    const splash=splashBase*lerp(1.0,0.65,tired);
    if(splash>0.15){
      ctx.globalAlpha=clamp(splash,0,0.65); ctx.fillStyle=PAL.foam;
      ctx.beginPath(); ctx.moveTo(x-4*s,y-1*s+bob); ctx.lineTo(x-7*s,y+2*s+bob); ctx.lineTo(x-2*s,y+2*s+bob); ctx.closePath(); ctx.fill();
      ctx.beginPath(); ctx.moveTo(x+4*s,y-1*s+bob); ctx.lineTo(x+7*s,y+2*s+bob); ctx.lineTo(x+2*s,y+2*s+bob); ctx.closePath(); ctx.fill();
      ctx.globalAlpha=1;
    }
    if(sw.flash>0){
      ctx.globalAlpha=sw.flash; ctx.fillStyle='#fff'; ctx.fillRect(x-6*s,y-10*s,12*s,20*s); ctx.globalAlpha=1;
    }
    if(sw.turnFlash>0){
      ctx.globalAlpha=sw.turnFlash*0.8; ctx.fillStyle='#fff'; ctx.fillRect((x-2)|0,(y-12)|0,4,1); ctx.globalAlpha=1;
    }
  }

  function drawHUD(){
    const p=swimmers.find(s=>s.isPlayer);
    const tSec=raceTimeMs/1000;
    const lapNum=getPlayerLapIndex()+1;
    ctx.fillStyle='rgba(0,0,0,.65)'; ctx.fillRect(0,0,W,22);
    drawPS1Text(6,5,`TIME ${tSec.toFixed(2)}`,PAL.ui,1.0,'left');
    drawPS1Text(W-6,5,`LAP ${lapNum}/${totalLengths}`,PAL.uiDim,1.0,'right');
    if(mode===MODE.QUICK) drawPS1Text(W/2,5,raceType.id==='CLASSIC300'?'300m':'', 'rgba(255,255,255,.0)',0.01,'center');

    const sx=6,sy=26,sw=110,sh=10;
    ctx.fillStyle='rgba(0,0,0,.55)'; ctx.fillRect(sx-2,sy-2,sw+4,sh+4);
    const segs=10;
    for(let i=0;i<segs;i++){
      const t=(i+1)/segs;
      const filled=p.stam>=t?1:(p.stam>i/segs?0.35:0);
      ctx.fillStyle=filled?(t>0.7?'#7cf':'#9fffb3'):'rgba(255,255,255,.10)';
      ctx.fillRect(sx+i*(sw/segs),sy,(sw/segs)-1,sh);
    }
    drawPS1Text(sx+sw+8,sy-1,'STAM',PAL.uiDim,0.95,'left');
    if(p.stam<=0.001) drawPS1Text(sx,sy+12,'EXHAUSTED',PAL.danger,0.95,'left');

    const rx=W-130,ry=26,rw=120,rh=10;
    ctx.fillStyle='rgba(0,0,0,.55)'; ctx.fillRect(rx-2,ry-2,rw+4,rh+4);
    const t0=rhythm.target-rhythm.sweet, t1=rhythm.target+rhythm.sweet;
    ctx.globalAlpha=0.9; ctx.fillStyle='rgba(124,255,190,.45)';
    ctx.fillRect(rx+clamp(t0,0,1)*rw,ry,clamp(t1,0,1)*rw-clamp(t0,0,1)*rw,rh);
    ctx.globalAlpha=1;
    const nx=rx+rhythm.phase*rw;
    ctx.fillStyle='#fff'; ctx.fillRect(nx|0,ry-2,1,rh+4);
    drawPS1Text(rx,ry-14,'TIMING',PAL.uiDim,0.95,'left');

    // Removed old hotkey hints
  }

  function drawStandings(){
    const x=W-122,y=44,w=116,h=86;
    ctx.fillStyle='rgba(0,0,0,.58)'; ctx.fillRect(x,y,w,h);
    drawPS1Text(x+6,y+6,'STANDINGS','#cfefff',0.95,'left');
    const rank=swimmers.slice().sort((a,b)=>b.dist-a.dist);
    for(let i=0;i<Math.min(6,rank.length);i++){
      const s=rank[i];
      const lineY=y+20+i*11;
      const col=s.isPlayer?'#7cf':'#eaeaea';
      drawPS1Text(x+6,lineY,`${i+1}. L${s.lane+1}`,col,0.95,'left');
      const pct=clamp(s.dist/totalM,0,1);
      ctx.globalAlpha=0.9;
      ctx.fillStyle=s.isPlayer?'rgba(124,255,255,.55)':'rgba(255,255,255,.22)';
      ctx.fillRect(x+54,lineY+3,(54*pct)|0,5);
      ctx.globalAlpha=1;
    }
  }

  // ====== Pause Menu (New) ======
  function drawPause(){
    // Dark overlay
    ctx.fillStyle='rgba(0,0,0,0.65)';
    ctx.fillRect(0,0,W,H);

    // Scanlines stronger
    ctx.globalAlpha=0.2;
    ctx.fillStyle='#000';
    for(let y=0; y<H; y+=2) ctx.fillRect(0,y,W,1);
    ctx.globalAlpha=1;

    // Pulse text
    const pulse = Math.sin(now()/150);
    const alpha = 0.6 + 0.4 * ((pulse+1)/2);

    drawPS1Text(W/2, H/2 - 20, 'PAUSED', `rgba(255,210,74,${alpha})`, 1.5, 'center');

    drawPS1Text(W/2, H/2 + 20, 'SPACE = RESUME', '#eaeaea', 1.0, 'center');
    drawPS1Text(W/2, H/2 + 36, 'Q = QUIT   ESC = RESUME', 'rgba(255,255,255,0.6)', 0.9, 'center');
  }

  let strokeConsumed=false;
  let camShake=0, lastLapPunch=0, lastLapPulse=0, finishPunch=0;

  function applyTurnEffect(s){
    const staminaGood=s.stam>0.35;
    let mul=1.0;
    if(s.lastStrokeQ===1 && staminaGood) mul=1.04;
    else if(s.lastStrokeQ===-1 || s.stam<0.12) mul=0.94;
    s.v*=mul; s.turnFlash=1.0; sfx.turn();
    if(getPlayerLapIndex()===totalLengths-1) s.v*=1.01;
  }

  function playerStroke(p){
    if(p.finishMs!==null) return;
    if(p.stam<=0.001){
      say('OUT OF STAMINA!', '#ff6a6a', 1.1, 2);
      if(p.exhaustedBuzz<=0){ p.exhaustedBuzz=0.35; sfx.exhausted(); }
      p.flash=0.15; return;
    }
    const distPhase=Math.min(Math.abs(rhythm.phase-rhythm.target),1-Math.abs(rhythm.phase-rhythm.target));
    const inGreen=distPhase<=rhythm.sweet;
    const near=distPhase<=rhythm.sweet*2.0;
    const sprint=!sprintDisabled && sprintHeld && p.stam>0.14;
    const baseBoost=sprint?3.30:1.48;
    const boostMul=inGreen?1.28:near?1.00:0.70;
    const greenTapCost=0.025;
    const baseCost=sprint?0.20:0.06;
    let cost;
    if(inGreen && !sprint) cost=greenTapCost;
    else{
      const timingCostMul=inGreen?0.85:near?1.10:2.10;
      cost=baseCost*timingCostMul*diff.stamDrainMul;
    }
    p.v += baseBoost*boostMul;
    p.stam = clamp(p.stam - cost, 0, 1);
    tech.taps++;
    if(sprint) tech.sprintTaps++;
    tech.stamSpent += cost;
    if(inGreen) tech.green++;
    else if(near) tech.near++;
    else tech.bad++;
    if(!near) p.v *= 0.88;
    p.lastStrokeQ=inGreen?1:near?0:-1;
    p.flash=inGreen?0.78:near?0.42:0.18;
    p.bob += 0.25 + boostMul*0.18;
    if(inGreen){
      sfx.tapGood();
      if(tech.green % 6 === 0) say('PERFECT STROKE!', '#7cf', 1.0, 1);
      else if(Math.random()<0.12) say('NICE TIMING', 'rgba(124,255,255,.85)', 0.9, 0);
      const lenIdx=clamp(lengthIndex(p.dist),0,totalLengths-1);
      const dir=dirForLength(lenIdx);
      const mInLen=clamp(posInLength(p.dist,lenIdx),0,LENGTH_M);
      const y=meterToScreenY(mInLen,dir);
      const x=laneXAt(y,p.lane);
      spawnSparks(x,y-1,9);
      camShake=Math.min(1.0,camShake+0.35);
    }else if(near){ sfx.tapOk(); if(Math.random()<0.10) say('KEEP THE RHYTHM', 'rgba(255,255,255,.78)', 0.9, 0); }
    else { sfx.tapBad(); if(Math.random()<0.18) say('OFF BEAT!', '#ff6a6a', 0.95, 1); }

    // Fake vibration logic
    if(settings.vibration && !settings.reducedMotion){
        camShake += 0.15; // Small kick on every stroke
    }
  }

  function aiStroke(s,dt){
    if(s.finishMs!==null) return;
    if(s.stam<=0.001) return;
    const prog=clamp(s.dist/totalM,0,1);
    let typeCad=1.0,typeTiming=1.0,typeDrain=1.0,lateBoost=1.0;
    switch(s.aiType){
      case 'SPRINTER': typeCad=prog<0.35?1.18:0.92; typeTiming=prog<0.35?0.98:0.90; typeDrain=prog<0.35?1.12:0.92; break;
      case 'PACER': typeCad=1.02; typeTiming=1.03; typeDrain=0.95; break;
      case 'CHOKER': typeCad=prog<0.55?1.06:0.95; typeTiming=prog<0.55?1.00:0.86; typeDrain=prog<0.55?1.00:1.10; break;
      case 'CLUTCH': typeCad=prog<0.60?0.98:1.12; typeTiming=prog<0.60?0.95:1.05; lateBoost=prog>0.75?1.06:1.00; typeDrain=prog<0.60?0.96:1.04; break;
    }
    const stamGate=lerp(0.62,1.03,clamp(s.stam,0,1));
    const cadence=s.aiCadence*lerp(1.00,1.18,s.aiSkill)*typeCad*(diff.name==='hard'?1.10:diff.name==='normal'?1.06:1.00)*stamGate;
    s.strokeTimer += dt*cadence;
    if(s.strokeTimer>=1.0){
      s.strokeTimer-=1.0;
      const timingQuality=lerp(0.72,0.96,s.aiSkill)*typeTiming;
      const goodRoll=Math.random();
      const isGreen=goodRoll < clamp(timingQuality,0.45,0.97);
      const near=!isGreen && goodRoll < clamp(timingQuality+0.22,0.55,0.995);
      const staminaFactor=lerp(0.70,1.08,s.stam);
      const staminaBoostGate=0.75+0.25*s.stam;
      const jitter=rand(-0.10,0.10)*(1.0-s.aiSkill);
      const base=isGreen?1.42:near?1.25:1.06;
      const boost=(base+s.aiSkill*0.90+jitter)*staminaFactor*staminaBoostGate*diff.aiMul*lateBoost;
      s.v += boost;
      const greenTapCost=0.025;
      if(isGreen){
        s.stam=clamp(s.stam-greenTapCost*typeDrain,0,1); s.lastStrokeQ=1;
      }else{
        const drainBase=(diff.name==='hard'?0.085:(diff.name==='normal'?0.070:0.050));
        const timingDrainMul=near?1.00:1.22;
        s.stam=clamp(s.stam-(drainBase*timingDrainMul*diff.stamDrainMul*typeDrain)*rand(0.90,1.10),0,1);
        s.lastStrokeQ=near?0:-1;
      }
    }
  }

  function physicsStep(dt){
    for(const s of swimmers){
      const drag=1.9*diff.dragMul;
      s.v=Math.max(0,s.v-drag*dt);
      if(s.stam<=0.001){
        s.v *= (diff.name==='hard'?0.90:0.92); if(s.v<0.12) s.v=0;
      }
      const recBase=0.22;
      let rec=recBase*diff.stamRecMul + (diff.name==='easy'?0.04:0);

      // Boost player recovery rate (1.6x = 60% faster)
      if(s.isPlayer) rec *= 1.6;

      const speedScale=clamp(1.0-(s.v/3.0),0.20,1.00);
      rec*=speedScale;
      if(s.v<0.25) rec*=1.35;
      if(s.isPlayer && sprintHeld) rec*=0.35;
      if(!s.isPlayer){ rec *= (diff.name==='easy'?0.95:(diff.name==='normal'?0.88:0.82)); }
      s.stam=clamp(s.stam+rec*dt,0,1);

      const prevDist=s.dist;
      s.dist += s.v*dt;
      const prevLen=(prevDist/LENGTH_M)|0;
      const newLen=(s.dist/LENGTH_M)|0;
      if(newLen!==prevLen && s.dist<totalM){
        applyTurnEffect(s); s.v*=0.92;
        // Split check
        if(s.isPlayer){
             showSplit(newLen * LENGTH_M, raceTimeMs/1000);
        }
      }
      s.turnFlash=Math.max(0,s.turnFlash-dt*3.0);

      // FINISH LOGIC
      if(s.dist>=totalM && s.finishMs===null){
        s.dist=totalM;
        s.finishMs=raceTimeMs;
        s.flash=1.0;
        sfx.finish();
        if(s.isPlayer){
            finishPunch = 0.04;
        }
      }
      s.exhaustedBuzz=Math.max(0,s.exhaustedBuzz-dt);
      s.flash=Math.max(0,s.flash-dt*2.6);
    }
  }

  let bootT=0;
  function drawBoot(t){
    clear('#000');
    const flick=(Math.sin(t*12)+1)/2;
    drawPS1Text(W/2,110,'OLYMPIC SWIM 98','#eaeaea',1.15,'center');
    ctx.globalAlpha=0.65+flick*0.25;
    drawPS1Text(W/2,150,'PRESS  ✕  TO START','#ffd24a',1.0,'center');
    ctx.globalAlpha=1;
    drawPS1Text(W/2,214,'© 1998  (NOT REAL)  ALL NAMES FICTIONAL','rgba(255,255,255,.55)',0.8,'center');
  }

  function drawMemoryCard(){
    clear('#000');
    drawPool(raceTimeMs/1000);
    ctx.fillStyle='rgba(0,0,0,.72)'; ctx.fillRect(0,0,W,H);
    drawPS1Text(W/2,16,'MEMORY CARD','#cfefff',1.35,'center');
    drawPS1Text(W/2,34,'SLOT A  •  SWIM DATA','rgba(255,255,255,.65)',0.95,'center');
    ctx.fillStyle='rgba(0,0,0,.60)'; ctx.fillRect(20,48,W-40,176);
    drawPS1Text(28,56,'QUICK RACE BESTS','rgba(255,255,255,.78)',0.95,'left');
    const rows = [['EASY','easy'],['NORMAL','normal'],['HARD','hard']];
    let y=70;
    for(const [lbl,df] of rows){
      drawPS1Text(28,y,`${lbl}`, df==='normal'?'#7cf':df==='hard'?'#ffd24a':'#eaeaea',0.9,'left');
      let xR = W-28;
      const order = [raceType.id, ...RACE_TYPES.map(r=>r.id).filter(id=>id!==raceType.id)];
      let line = '';
      for(const rid of order){
        const k = `${df}_${rid}`;
        const v = mem.quickBest[k];
        line += `${rid==='SPRINT100'?'100':rid==='ENDURANCE800'?'800':'300'}:${v!=null? v.toFixed(2)+'s':'--'}   `;
      }
      drawPS1Text(xR,y,line.trim(),'rgba(255,255,255,.72)',0.75,'right');
      y+=12;
    }
    y+=8;
    drawPS1Text(28,y,'GAUNTLET BEST SURVIVAL (ROUNDS CLEARED)','rgba(255,255,255,.78)',0.95,'left');
    y+=14;
    const gE = mem.gauntletBestStage.easy??0, gN=mem.gauntletBestStage.normal??0, gH=mem.gauntletBestStage.hard??0;
    drawPS1Text(28,y,`EASY: ${gE}/7   NORMAL: ${gN}/7   HARD: ${gH}/7`,'rgba(255,255,255,.72)',0.9,'left');

    // New stats
    y+=16;
    drawPS1Text(28,y,'LIFETIME STATS','rgba(255,255,255,.78)',0.95,'left');
    y+=12;
    // Calculate best overall gauntlet streak across diffs
    const maxStreak = Math.max(gE, gN, gH);
    drawPS1Text(28,y,`TOTAL HEATS: ${mem.totalHeats||0}   BEST GAUNTLET STREAK: ${maxStreak}`, 'rgba(255,255,255,.70)', 0.85, 'left');

    y+=16;
    drawPS1Text(28,y,'LAST PLAYED','rgba(255,255,255,.78)',0.95,'left');
    y+=12;
    drawPS1Text(28,y, mem.lastPlayed ? mem.lastPlayed : '--', 'rgba(255,255,255,.70)',0.85,'left');
    ctx.fillStyle='rgba(0,0,0,.62)'; ctx.fillRect(20,206,W-40,22);
    drawPS1Text(W/2,210,'PRESS ✕ TO RETURN   •   DEL = CLEAR DATA','rgba(255,255,255,.72)',0.9,'center');
  }

  function drawMenu(t){
    clear('#000');
    drawPool(t);
    ctx.fillStyle='rgba(0,0,0,.55)'; ctx.fillRect(0,0,W,H);
    drawPS1Text(W/2,20,'MODE SELECT','#cfefff',1.2,'center');
    ctx.fillStyle='rgba(255,255,255,.10)'; ctx.fillRect(56,42,W-112,22);
    drawPS1Text(W/2,44, mode===MODE.QUICK ? 'QUICK RACE' : 'GAUNTLET (ELIMINATION)', mode===MODE.QUICK ? '#7cf' : '#ffd24a', 1.05, 'center');
    drawPS1Text(60,44,'◀/▶', 'rgba(255,255,255,.55)', 0.9, 'left');
    drawPS1Text(W/2,72,'DIFFICULTY', 'rgba(255,255,255,.75)', 0.95, 'center');
    ctx.fillStyle='rgba(255,255,255,.07)'; ctx.fillRect(48,64,W-96,16);
    drawPS1Text(54,66,'RACE', 'rgba(255,255,255,.55)', 0.85, 'left');
    const rtLabel = (mode===MODE.QUICK) ? raceType.label : 'CLASSIC 300m (GAUNTLET)';
    drawPS1Text(W-54,66,rtLabel, mode===MODE.QUICK ? 'rgba(255,255,255,.78)' : 'rgba(255,255,255,.45)', 0.85, 'right');
    for(let i=0;i<menuItems.length;i++){
      const it=menuItems[i];
      const y=96+i*26;
      const sel=i===menuSel;
      ctx.fillStyle=sel?'rgba(124,255,255,.22)':'rgba(255,255,255,.08)';
      ctx.fillRect(70,y-2,W-140,20);
      drawPS1Text(W/2,y,it.label,sel?'#7cf':'#eaeaea',1.05,'center');
      if(sel) drawPS1Text(84,y,'▶','#7cf',1.0,'left');
    }
    ctx.fillStyle='rgba(0,0,0,.45)'; ctx.fillRect(18,196,W-36,38);
    drawPS1Text(24,200,'Green timing = faster + only 2.5% stamina per tap.','rgba(255,255,255,.75)',0.85,'left');
    drawPS1Text(24,212,'Pace to recover while swimming. Sprint reduces recovery.','rgba(255,255,255,.70)',0.85,'left');
  }

  // ====== Options Menu (New) ======
  const optionItems = [
    { id:'sfxVolume', label:'SFX VOLUME', vals:['LOW','MED','HIGH'] },
    { id:'dither', label:'DITHER', vals:[false,true], display:v=>v?'ON':'OFF' },
    { id:'crt', label:'CRT EFFECT', vals:[false,true], display:v=>v?'ON':'OFF' },
    { id:'reducedMotion', label:'REDUCE MOTION', vals:[false,true], display:v=>v?'ON':'OFF' }
  ];
  let optionSel = 0;

  function drawOptions(){
    clear('#000');
    // Backdrop
    drawPool(raceTimeMs/1000);
    ctx.fillStyle='rgba(0,0,0,.60)'; ctx.fillRect(0,0,W,H);

    drawPS1Text(W/2, 20, 'OPTIONS', '#cfefff', 1.2, 'center');

    const panelX = 40, panelY = 50, panelW = W-80, panelH = 140;
    ctx.fillStyle='rgba(0,0,0,.6)'; ctx.fillRect(panelX, panelY, panelW, panelH);
    ctx.strokeStyle='rgba(255,255,255,.12)'; ctx.strokeRect(panelX+0.5, panelY+0.5, panelW-1, panelH-1);

    for(let i=0; i<optionItems.length; i++){
        const item = optionItems[i];
        const y = panelY + 24 + i*28;
        const sel = (i === optionSel);

        // Row Highlight
        if(sel){
            ctx.fillStyle = 'rgba(124,255,255,.15)';
            ctx.fillRect(panelX+4, y-4, panelW-8, 18);
        }

        // Label
        drawPS1Text(panelX+12, y, item.label, sel?'#7cf':'#eaeaea', 1.0, 'left');

        // Value
        const val = settings[item.id];
        let disp = val;
        if(item.display) disp = item.display(val);

        drawPS1Text(panelX+panelW-12, y, `< ${disp} >`, sel?'#ffd24a':'rgba(255,255,255,.6)', 1.0, 'right');
    }

    // Instructions
    ctx.fillStyle='rgba(0,0,0,.62)'; ctx.fillRect(20,206,W-40,22);
    drawPS1Text(W/2,210,'PRESS ✕ TO RETURN', 'rgba(255,255,255,.72)', 0.9, 'center');
  }

  function drawGauntletHubFixed(){
    clear('#000');
    drawPool(raceTimeMs/1000);
    ctx.fillStyle='rgba(0,0,0,.66)'; ctx.fillRect(0,0,W,H);
    drawPS1Text(W/2,18,'GAUNTLET','#cfefff',1.4,'center');
    drawPS1Text(W/2,38,`${diff.name.toUpperCase()}  •  300m`, 'rgba(255,255,255,.65)', 0.95, 'center');
    const remaining = g_remainingNpcs;
    const round = GAUNTLET_START_NPCS - remaining + 1;
    ctx.fillStyle='rgba(0,0,0,.55)'; ctx.fillRect(30,60,W-60,110);
    drawPS1Text(40,70,`ROUND ${round}/8`, '#ffd24a', 1.1, 'left');
    drawPS1Text(40,88,`OPPONENTS LEFT: ${remaining}`, '#eaeaea', 1.0, 'left');
    drawPS1Text(40,104,`NEXT HEAT FIELD: ${Math.max(1, remaining)} NPC`, '#eaeaea', 1.0, 'left');
    ctx.globalAlpha=0.9;
    for(let i=0;i<GAUNTLET_START_NPCS;i++){
      const y=124+i*10;
      const alive = i < remaining;
      ctx.fillStyle= alive ? 'rgba(255,255,255,.18)' : 'rgba(255,255,255,.06)';
      ctx.fillRect(42,y,10,6);
      ctx.fillStyle= alive ? '#eaeaea' : 'rgba(255,255,255,.35)';
      drawPS1Text(58,y-2, alive ? `NPC ${i+1}` : `NPC ${i+1} (OUT)`, alive ? '#eaeaea' : 'rgba(255,255,255,.35)', 0.85, 'left');
    }
    ctx.globalAlpha=1;
    ctx.fillStyle='rgba(0,0,0,.62)'; ctx.fillRect(20,186,W-40,44);
    if(g_heatModifier){
      drawPS1Text(W/2,188,`MODIFIER: ${g_heatModifier.label}`,'#ffd24a',0.90,'center');
      drawPS1Text(W/2,200,g_heatModifier.desc,'rgba(255,255,255,.72)',0.80,'center');
    }else{
      drawPS1Text(W/2,192,'NO MODIFIER','rgba(255,255,255,.55)',0.85,'center');
    }
    drawPS1Text(W/2,212,'ELIMINATION: LAST PLACE OUT','rgba(255,255,255,.70)',0.85,'center');
    drawPS1Text(W/2,224,'PRESS ✕ TO START NEXT HEAT','#7cf',0.95,'center');
    drawPS1Text(W/2,234,'ESC = BACK TO MENU','rgba(255,255,255,.55)',0.82,'center');
  }

  function gradeFromPct(p){
    if(p>=0.82) return 'A'; if(p>=0.64) return 'B'; return 'C';
  }
  function calcTechniqueGrades(){
    const acc = tech.taps ? (tech.green*1.0 + tech.near*0.55) / tech.taps : 0;
    const timingGrade = gradeFromPct(acc);
    const spentPerTap = tech.taps ? tech.stamSpent / tech.taps : 1;
    const eff = clamp(1 - ((spentPerTap-0.04)/0.07), 0, 1);
    const staminaGrade = gradeFromPct(eff);
    const sprintRatio = tech.taps ? tech.sprintTaps / tech.taps : 0;
    const disc = clamp(1 - Math.abs(sprintRatio-0.28)/0.35, 0, 1);
    const sprintGrade = gradeFromPct(disc);
    return { timingGrade, staminaGrade, sprintGrade, acc, spentPerTap, sprintRatio };
  }
  function rankTitle(playerTime,bestTime){
    const d=playerTime-bestTime;
    if(d<=0.02) return 'LEGENDARY RUN';
    if(d<=0.35) return 'WORLD CLASS';
    if(d<=0.90) return 'OLYMPIC QUALIFIER';
    if(d<=1.70) return 'NATIONAL LEVEL';
    return 'KEEP TRAINING';
  }

  function drawResult(){
    clear('#000');
    drawPool(raceTimeMs/1000);
    ctx.fillStyle='rgba(0,0,0,.62)'; ctx.fillRect(0,0,W,H);
    ensureLastRace();
    const title = (mode===MODE.GAUNTLET) ? 'ROUND SCOREBOARD' : 'FINAL SCOREBOARD';
    drawPS1Text(W/2,14,title,'#cfefff',1.35,'center');
    drawPS1Text(W/2,34,`${lastRace.diff.toUpperCase()}  •  ${Math.round(totalM)}m`,'rgba(255,255,255,.65)',0.95,'center');
    const x=46,y=52,rowH=14;
    ctx.fillStyle='rgba(0,0,0,.55)'; ctx.fillRect(x-14,y-10,W-(x-14)*2,138);
    drawPS1Text(x,y-6,'POS   LANE   TIME','rgba(255,255,255,.75)',0.95,'left');
    for(let i=0;i<Math.min(8,lastRace.full.length);i++){
      const s=lastRace.full[i];
      const col=(s.lane===playerLane+1)?'#7cf':'#eaeaea';
      drawPS1Text(x,y+i*rowH,`${String(s.pos).padStart(2,' ')}     ${String(s.lane).padStart(2,' ')}     ${s.time.toFixed(2)}`,col,0.95,'left');
    }
    const grades = calcTechniqueGrades();
    const best=records[lastRace.diff] ?? lastRace.playerTime;
    const delta=lastRace.playerTime - best;
    const rtitle=rankTitle(lastRace.playerTime,best);
    ctx.fillStyle='rgba(0,0,0,.55)'; ctx.fillRect(20,196,W-40,36);
    drawPS1Text(26,200,`YOU: #${lastRace.playerPos}   ${lastRace.playerTime.toFixed(2)}s`,'#7cf',0.98,'left');
    drawPS1Text(W-26,200,`TECH:  TIM ${grades.timingGrade}   STAM ${grades.staminaGrade}   SPRINT ${grades.sprintGrade}`,'rgba(255,255,255,.75)',0.82,'right');
    drawPS1Text(26,212,`BEST: ${best.toFixed(2)}s   Δ ${delta>=0?'+':''}${delta.toFixed(2)}s   ${rtitle}`,'#ffd24a',0.88,'left');
    if(mode===MODE.GAUNTLET){
      drawPS1Text(W/2, 232-10, 'PRESS ✕ TO CONTINUE', 'rgba(255,255,255,.72)', 0.95, 'center');
    } else {
      drawPS1Text(W/2, 232-10, 'PRESS ✕ TO MENU', 'rgba(255,255,255,.72)', 0.95, 'center');
    }
  }

  function drawGauntletWin(){
    clear('#000');
    drawPool(raceTimeMs/1000);
    ctx.fillStyle='rgba(0,0,0,.70)'; ctx.fillRect(0,0,W,H);
    drawPS1Text(W/2,70,'GAUNTLET CHAMPION','#ffd24a',1.55,'center');
    drawPS1Text(W/2,96,'YOU SURVIVED EVERY ROUND','#eaeaea',1.0,'center');
    drawPS1Text(W/2,124,`DIFFICULTY: ${diff.name.toUpperCase()}`,'rgba(255,255,255,.65)',0.95,'center');
    drawPS1Text(W/2,160,'PRESS ✕ TO MENU','#7cf',1.05,'center');
  }

  function drawGauntletLose(){
    clear('#000');
    drawPool(raceTimeMs/1000);
    ctx.fillStyle='rgba(0,0,0,.70)'; ctx.fillRect(0,0,W,H);
    drawPS1Text(W/2,72,'GAUNTLET FAILED','#ff6a6a',1.55,'center');
    drawPS1Text(W/2,98,'YOU FINISHED LAST','#eaeaea',0.95,'center');
    drawPS1Text(W/2,126,'PRESS ✕ TO RETRY','#7cf',1.05,'center');
    drawPS1Text(W/2,146,'(GAUNTLET RESETS)','rgba(255,255,255,.55)',0.85,'center');
    drawPS1Text(W/2,170,'ESC = MENU','rgba(255,255,255,.55)',0.85,'center');
  }

  // ====== Saving Screen (New) ======
  function drawSaving(dt){
    clear('#000');
    // Simple pulse
    const pulse = Math.sin(now()/150);
    const alpha = 0.5 + 0.5 * ((pulse+1)/2);

    // Icon (simple square for mem card)
    ctx.fillStyle = `rgba(124,255,255,${alpha})`;
    ctx.fillRect(W/2 - 10, H/2 - 20, 20, 14);

    drawPS1Text(W/2, H/2 + 10, 'SAVING TO MEMORY CARD...', '#eaeaea', 1.0, 'center');
    drawPS1Text(W/2, H/2 + 26, 'DO NOT REMOVE CARD', '#ff6a6a', 0.9, 'center');
  }

  // ====== Menu navigation ======
  let savingNextState = STATE.MENU;
  let savingTimer = 0;

  window.addEventListener('keydown',(e)=>{
    if(trans.active) return; // Block input during fade
    if(state===STATE.SAVING) return; // Block input during save

    if(state===STATE.MENU){
      if(e.code==='ArrowLeft' || e.code==='ArrowRight'){
        mode = (mode===MODE.QUICK) ? MODE.GAUNTLET : MODE.QUICK;
        sfx.ui();
      }
      if(mode===MODE.QUICK && (e.code==='BracketLeft' || e.code==='BracketRight')){
        const dir = (e.code==='BracketRight') ? 1 : -1;
        raceTypeSel = (raceTypeSel + RACE_TYPES.length + dir) % RACE_TYPES.length;
        raceType = RACE_TYPES[raceTypeSel];
        totalLengths = raceType.lengths;
        totalM = LENGTH_M * totalLengths;
        sfx.ui();
      }
      if(mode===MODE.QUICK && (e.code==='KeyA' || e.code==='KeyD' || e.code==='Comma' || e.code==='Period')){
        const dir = (e.code==='KeyD' || e.code==='Period') ? 1 : -1;
        raceTypeSel = (raceTypeSel + RACE_TYPES.length + dir) % RACE_TYPES.length;
        raceType = RACE_TYPES[raceTypeSel];
        totalLengths = raceType.lengths;
        totalM = LENGTH_M * totalLengths;
        sfx.ui();
      }
      if(e.code==='ArrowUp'){ menuSel=(menuSel+menuItems.length-1)%menuItems.length; sfx.ui(); }
      if(e.code==='ArrowDown'){ menuSel=(menuSel+1)%menuItems.length; sfx.ui(); }
      if(e.code==='KeyM'){
        transitionTo(STATE.MEMORY);
        pressed=false; anyKey=false; lastPtr.down=false; sfx.ui();
      }
      if(e.code==='Space' || e.code==='Enter'){
        const item = menuItems[menuSel];
        if(item.action === 'options'){
            transitionTo(STATE.OPTIONS);
            pressed=false; anyKey=false; sfx.ui(); e.preventDefault();
            return;
        }

        applyDifficulty(item.diff);
        if(mode===MODE.QUICK){
          raceType = RACE_TYPES[raceTypeSel]; totalLengths = raceType.lengths; totalM = LENGTH_M * totalLengths;
          transitionTo(STATE.RACE, ()=>resetRace(7));
        } else {
          g_remainingNpcs=GAUNTLET_START_NPCS;
          g_stage=0;
          raceType = RACE_TYPES[1]; totalLengths = raceType.lengths; totalM = LENGTH_M * totalLengths;
          transitionTo(STATE.GAUNTLET_HUB);
        }
        pressed=false; anyKey=false; sfx.ui(); e.preventDefault();
      }
    }

    if(state===STATE.OPTIONS){
        if(e.code==='ArrowUp'){ optionSel = (optionSel + optionItems.length - 1) % optionItems.length; sfx.ui(); }
        if(e.code==='ArrowDown'){ optionSel = (optionSel + 1) % optionItems.length; sfx.ui(); }

        if(e.code==='ArrowLeft' || e.code==='ArrowRight' || e.code==='Space' || e.code==='Enter'){
            const item = optionItems[optionSel];
            const currVal = settings[item.id];
            const idx = item.vals.indexOf(currVal);

            let nextIdx;
            if(e.code==='ArrowLeft') nextIdx = (idx + item.vals.length - 1) % item.vals.length;
            else nextIdx = (idx + 1) % item.vals.length;

            settings[item.id] = item.vals[nextIdx];
            saveSettings();
            sfx.ui();
        }

        if(e.code==='Escape' || e.code==='KeyX'){ // X matches prompt
            transitionTo(STATE.MENU);
            pressed=false; anyKey=false; sfx.ui();
        }
    }

    if(state===STATE.MEMORY){
      if(e.code==='Delete' || e.code==='Backspace'){
        mem = { quickBest:{}, gauntletBestStage:{easy:0,normal:0,hard:0}, lastPlayed:'' };
        saveMem(mem); sfx.ui(); e.preventDefault(); return;
      }
      if(e.code==='Space' || e.code==='Enter' || e.code==='KeyM'){
        transitionTo(STATE.MENU); sfx.ui(); e.preventDefault(); return;
      }
    }
    if(e.code==='Escape'){
      if(state===STATE.RACE){
          state=STATE.PAUSE; // Pause instead of quit
          pressed=false; anyKey=false; sfx.ui();
      } else if(state===STATE.PAUSE){
          state=STATE.RACE; // Unpause
          pressed=false; anyKey=false; sfx.ui();
      } else if(state!==STATE.BOOT && state!==STATE.MENU && state!==STATE.OPTIONS){
        transitionTo(STATE.MENU);
        pressed=false; anyKey=false; sfx.ui();
      }
    }
    // Pause menu specific
    if(state===STATE.PAUSE){
        if(e.code==='KeyQ'){ // Quit
            transitionTo(STATE.MENU);
            pressed=false; anyKey=false; sfx.ui();
        }
        if(e.code==='Space' || e.code==='Enter'){ // Resume
            state=STATE.RACE;
            pressed=false; anyKey=false; sfx.ui();
        }
    }
  },{passive:false});

  function present(timeS){
    const lapIdx=getPlayerLapIndex();
    const lastLap=lapIdx===totalLengths-1;
    const targetPunch=lastLap?0.018:0.0;

    // Smooth decays
    lastLapPunch=lerp(lastLapPunch,targetPunch,0.08);
    lastLapPulse=lerp(lastLapPulse,lastLap?(0.004*Math.sin(timeS*7.2)):0,0.10);
    finishPunch=lerp(finishPunch, 0, 0.12);
    camShake=Math.max(0,camShake-1.8*(1/60));

    const pr = getPressure();
    const shakePx=(settings.reducedMotion?0:camShake)*2.0 + (settings.reducedMotion?0:pr*1.2) + (finishPunch * 150);
    const sx=rand(-1,1)*shakePx;
    const sy=rand(-1,1)*shakePx;

    // Zoom logic: standard punch + pulse + impact punch
    const zoom=1.0+lastLapPunch+lastLapPulse+finishPunch;

    const dw=out.width*zoom, dh=out.height*zoom;
    const dx=(out.width-dw)/2+sx;
    const dy=(out.height-dh)/2+sy;
    octx.imageSmoothingEnabled=false;
    octx.clearRect(0,0,out.width,out.height);
    octx.drawImage(fb,dx,dy,dw,dh);
  }

  // ====== Main loop ======
  let last=now();
  let strokeConsumedLocal=false;
  function frame(){
    const t=now();
    let dt=(t-last)/1000; last=t;
    dt=clamp(dt,0,0.033);

    // Skip updates if paused
    if(state===STATE.PAUSE){
        drawPool(t/1000); // Keep drawing BG
        // Draw swimmers static
        const sorted=swimmers.slice().sort((a,b)=>a.dist-b.dist);
        for(const s of sorted) drawSwimmer(s,t/1000);
        drawHUD();
        drawStandings();
        drawPause(); // Overlay

        if(settings.crt) crtOverlay(t/1000);
        present(t/1000);
        requestAnimationFrame(frame);
        return;
    }

    rhythm.phase=(rhythm.phase+dt*rhythm.speed)%1.0;
    stepSparks(dt);
    stepCommentary(dt);

    if(lastSplitObj && lastSplitObj.timer > 0) lastSplitObj.timer -= dt;

    // Transition Fades
    if(trans.active){
        trans.t += dt;
        if(trans.t >= trans.dur/2 && state !== trans.targetState){
            state = trans.targetState;
            if(trans.onMid) trans.onMid();
        }
        if(trans.t >= trans.dur){
            trans.active=false;
        }
    }

    if(state===STATE.BOOT){
      bootT+=dt;
      drawBoot(bootT);
      if((pressed||anyKey) && bootT>0.25){
        pressed=false; anyKey=false;
        transitionTo(STATE.MENU);
        sfx.ui();
      }
    }
    else if(state===STATE.MENU){
      drawMenu(t/1000);
      if(pressed && !trans.active){
        if(mode===MODE.QUICK && lastPtr.down){
          const rx=48, ry=64, rw=W-96, rh=16;
          if(lastPtr.x>=rx && lastPtr.x<=rx+rw && lastPtr.y>=ry && lastPtr.y<=ry+rh){
            raceTypeSel = (raceTypeSel + 1) % RACE_TYPES.length;
            raceType = RACE_TYPES[raceTypeSel];
            totalLengths = raceType.lengths;
            totalM = LENGTH_M * totalLengths;
            sfx.ui();
            pressed=false; lastPtr.down=false;
            present(t/1000); requestAnimationFrame(frame); return;
          }
        }
        if(lastPtr.down){
          const bx=W-96, by=176, bw=76, bh=16;
          if(lastPtr.x>=bx && lastPtr.x<=bx+bw && lastPtr.y>=by && lastPtr.y<=by+bh){
            transitionTo(STATE.MEMORY);
            pressed=false; lastPtr.down=false; anyKey=false; sfx.ui();
            present(t/1000); requestAnimationFrame(frame); return;
          }
        }

        const item = menuItems[menuSel];
        if(item.action === 'options'){
            transitionTo(STATE.OPTIONS);
            pressed=false; anyKey=false; sfx.ui();
            present(t/1000); requestAnimationFrame(frame); return;
        }

        applyDifficulty(item.diff);
        if(mode===MODE.QUICK){
          raceType = RACE_TYPES[raceTypeSel]; totalLengths = raceType.lengths; totalM = LENGTH_M * totalLengths;
          transitionTo(STATE.RACE, ()=>resetRace(7));
        } else {
          g_remainingNpcs=GAUNTLET_START_NPCS;
          g_stage=0;
          raceType = RACE_TYPES[1]; totalLengths = raceType.lengths; totalM = LENGTH_M * totalLengths;
          transitionTo(STATE.GAUNTLET_HUB);
        }
        pressed=false; anyKey=false; sfx.ui();
      }
    }
    else if(state===STATE.OPTIONS){
        drawOptions();
        // Mouse handling for options
        if(pressed && !trans.active && lastPtr.down){
            // Check rows
            const panelX = 40, panelY = 50, panelW = W-80;
            if(lastPtr.x >= panelX && lastPtr.x <= panelX+panelW){
                for(let i=0; i<optionItems.length; i++){
                    const y = panelY + 24 + i*28;
                    // Simple hit box for row
                    if(lastPtr.y >= y-10 && lastPtr.y <= y+10){
                        // If different row, select it
                        if(optionSel !== i){
                            optionSel = i;
                            sfx.ui();
                        } else {
                            // If same row, toggle
                            const item = optionItems[i];
                            const currVal = settings[item.id];
                            const idx = item.vals.indexOf(currVal);
                            const nextIdx = (idx + 1) % item.vals.length;
                            settings[item.id] = item.vals[nextIdx];
                            saveSettings();
                            sfx.ui();
                        }
                        pressed=false; lastPtr.down=false;
                        break;
                    }
                }
            }
            // Check back button area
            if(lastPtr.y > 200){
                transitionTo(STATE.MENU);
                pressed=false; anyKey=false; sfx.ui();
            }
        }
    }
    else if(state===STATE.GAUNTLET_HUB){
      if(!g_heatModifier){ g_heatModifier = HEAT_MODIFIERS[(Math.random()*HEAT_MODIFIERS.length)|0]; }
      drawGauntletHubFixed();
      if((pressed||anyKey) && !trans.active){
        pressed=false; anyKey=false;
        const fieldNpcs=Math.max(1,g_remainingNpcs);
        raceType = RACE_TYPES[1]; totalLengths = raceType.lengths; totalM = LENGTH_M * totalLengths;
        transitionTo(STATE.RACE, ()=>resetRace(fieldNpcs));
        resultLock=0; sfx.ui();
      }
    }
    else if(state===STATE.RACE){
      if(countdown>0){
        countdown-=dt; if(countdown<0) countdown=0;

        // Countdown Audio
        const ceilNow = Math.ceil(countdown);
        if(ceilNow < lastCountdownCeil){
            if(ceilNow===0) sfx.countHigh(); // GO!
            else sfx.countLow(); // 3.. 2.. 1..
            lastCountdownCeil = ceilNow;
        }

      } else {
        raceTimeMs+=dt*1000;
      }
      const p=swimmers.find(s=>s.isPlayer);
      if(countdown===0){
        if(pressed && !strokeConsumedLocal){ playerStroke(p); strokeConsumedLocal=true; }
        if(!pressed) strokeConsumedLocal=false;
      } else { if(!pressed) strokeConsumedLocal=false; }
      if(countdown===0){
        for(const s of swimmers) if(!s.isPlayer) aiStroke(s,dt);
        physicsStep(dt);
      }
      drawPool(t/1000);
      const sorted=swimmers.slice().sort((a,b)=>a.dist-b.dist);
      for(const s of sorted) drawSwimmer(s,t/1000);
      drawSparks();
      drawHUD();
      drawStandings();
      drawCommentary();
      drawPressureOverlay(t/1000);

      // Draw Splits
      drawSplitPopup();

      if(countdown===0){
        const rankNow = swimmers.slice().sort((a,b)=>b.dist-a.dist);
        if(rankNow[0] && rankNow[0].isPlayer && tech.leadCalls<1){
          say('TAKING THE LEAD!', '#ffd24a', 1.0, 1); tech.leadCalls++;
        }
      }
      if(p.turnFlash>0.6) drawPS1Text(W/2,100,'TURN!','#ffd24a',1.4,'center');
      if(countdown>0){
        ctx.fillStyle='rgba(0,0,0,.55)'; ctx.fillRect(0,0,W,H);
        drawPS1Text(W/2,78,'GET READY','#cfefff',1.3,'center');
        drawPS1Text(W/2,110,String(Math.ceil(countdown)),'#ffd24a',2.8,'center');
        drawPS1Text(W/2,160,'GREEN TIMING = SAVE STAMINA','rgba(255,255,255,.75)',0.95,'center');
        if(mode===MODE.GAUNTLET){
          drawPS1Text(W/2,178,`GAUNTLET • NPC LEFT: ${g_remainingNpcs}`,'rgba(255,255,255,.70)',0.9,'center');
        }
      } else if(mode===MODE.GAUNTLET){
        drawPS1Text(10, 42, `GAUNTLET • NPC LEFT: ${g_remainingNpcs}`, 'rgba(255,255,255,.55)', 0.85, 'left');
      }
      if(allFinished()){
        updateRecords();
        pressed=false; anyKey=false;
        resultLock=0.55;
        transitionTo(STATE.RESULT);
      }
    }
    else if(state===STATE.RESULT){
      drawResult();
      if(resultLock>0) resultLock-=dt;
      if(resultLock<=0 && (pressed||anyKey) && !trans.active){
        pressed=false; anyKey=false;

        // Go to SAVE screen first
        if(mode===MODE.GAUNTLET){
          const total = lastRace.full.length;
          const survived = (lastRace.playerPos !== total);
          if(survived){
            g_remainingNpcs = Math.max(0, g_remainingNpcs - 1);
            g_stage++;
            const pos = lastRace.playerPos;
            const ratio = (total>1) ? (1 - (pos-1)/(total-1)) : 1;
            g_playerCarryStam = clamp(0.78 + ratio*0.22 + (Math.random()*0.05-0.025), 0.75, 1.0);
            g_npcCarryMul = clamp(0.84 + Math.random()*0.10, 0.84, 0.95);
            g_heatModifier = null;
            sfx.win();
            // Decide where to go after save
            savingNextState = (g_remainingNpcs<=0) ? STATE.GAUNTLET_WIN : STATE.GAUNTLET_HUB;
          }else{
            sfx.lose();
            g_playerCarryStam = 1.0; g_npcCarryMul = 1.0; g_heatModifier = null;
            savingNextState = STATE.GAUNTLET_LOSE;
          }
        } else {
          savingNextState = STATE.MENU; sfx.ui();
        }

        // Initiate save sequence
        savingTimer = 0.8;
        transitionTo(STATE.SAVING);
      }
    }
    else if(state===STATE.SAVING){
        drawSaving(dt);
        savingTimer -= dt;
        if(savingTimer <= 0 && !trans.active){
            transitionTo(savingNextState);
        }
    }
    else if(state===STATE.GAUNTLET_LOSE){
      drawGauntletLose();
      if(pressed && !trans.active){
        pressed=false; anyKey=false;
        g_remainingNpcs=GAUNTLET_START_NPCS; g_stage=0;
        transitionTo(STATE.GAUNTLET_HUB); sfx.ui();
      }
    }
    else if(state===STATE.MEMORY){
      drawMemoryCard();
      if(pressed && !trans.active){
        pressed=false; anyKey=false;
        transitionTo(STATE.MENU); sfx.ui();
      }
    }
    else if(state===STATE.GAUNTLET_WIN){
      drawGauntletWin();
      if(pressed && !trans.active){
        pressed=false; anyKey=false;
        transitionTo(STATE.MENU); sfx.ui();
      }
    }

    if(settings.crt) crtOverlay(t/1000);
    if(settings.dither) ditherOverlay(0.10);

    // Apply Fade Overlay
    if(trans.active){
        const fadeProg = trans.t / trans.dur;
        // alpha 0 -> 1 -> 0
        const alpha = Math.sin(fadeProg * Math.PI);
        ctx.fillStyle=`rgba(0,0,0,${Math.min(1, alpha * 1.5)})`;
        ctx.fillRect(0,0,W,H);
    }

    present(t/1000);
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>